#!/usr/bin/env python
# coding: utf-8

# In[1]:


import pandas
import numpy
import cvxopt
import time
import matplotlib.pyplot as plt

import sys


# In[2]:

if len(sys.argv) != 3:
	print("Please provide relative or absolute <path_of_train_data>Â and <path_of_test_data> as command line arguments.")
	sys.exit()
train_path = sys.argv[1]
test_path = sys.argv[2]

# train_df = pandas.read_csv('../mnist/train.csv', header=None)
# test_df = pandas.read_csv('../mnist/test.csv', header=None)
try:
	train_df = pandas.read_csv(train_path, header=None)
	test_df = pandas.read_csv(test_path, header=None)
except:
	print("Error: Incorrect path for data")
	sys.exit()

# In[3]:


train_data = train_df.to_numpy()
test_data = test_df.to_numpy()

m = train_data.shape[0] # no. of training examples
n = train_data.shape[1]-1 # no. of features, last column is label

train_X = train_data[:,0:n]
train_Y = train_data[:,n]
# print(train_X.shape)
# print(train_Y.shape)

test_X = test_data[:,0:n]
test_Y = test_data[:,n]
# print(test_X.shape)
# print(test_Y.shape)


# In[4]:


train_X = train_X/255 # rescale from [0,255] to [0,1]
test_X = test_X/255

print("Extracting examples with labels 4 and 5...")
mask = numpy.any([test_Y==4, test_Y==5], axis=0)
test_X_subset = test_X[mask]
test_Y_subset = test_Y[mask]


# In[5]:

print("\nCONFUSION MATRIX FOR PART 2.1(a)")
print("Using cached predictions generated by 'question2_1a.py'...")
prediction_data = numpy.loadtxt('2_1a_test_prediction.csv', delimiter=',')
print(prediction_data)

# Confusion Matrix

confusion_matrix = numpy.empty((2, 2), dtype=numpy.int64)
for i in range(2):
    label_i_mask = (test_Y_subset==(i+4))
    for j in range(2):
        predicted_j_actual_i = (prediction_data[label_i_mask]==(j+4))        
        # confusion_matrix[i,j] = no. of examples of actual class (i+4) predicted as class (j+4)
        confusion_matrix[i,j] = numpy.count_nonzero(predicted_j_actual_i)
print("\nConfusion Matrix: (i,j) th value represents no. of examples of actual class (i+4) predicted as class (j+4)")        
print(confusion_matrix)

print("\nSome Misclassified Images")

misclassified_images = test_X_subset[prediction_data!=test_Y_subset]
labels = test_Y_subset[prediction_data!=test_Y_subset]
predicted = prediction_data[prediction_data!=test_Y_subset]
misclassified_images = (255*misclassified_images).astype(numpy.uint8)
w, h = 28, 28

fig, axs = plt.subplots(4, 4)
fig.set_size_inches(8, 8)
for i in range(4):
    for j in range(4):
        axs[i, j].plot()
        axs[i, j].imshow(numpy.reshape(misclassified_images[4*i + j], newshape=(w,h)), cmap=plt.get_cmap('gray'))
        axs[i, j].set_title(f"L={labels[4*i + j]} P={int(predicted[4*i + j])}")

# Hide x labels and tick labels for top plots and y ticks for right plots.
for ax in axs.flat:
    ax.label_outer()

plt.savefig("2_2c_i1_misclassified_images.png", dpi=100)
plt.show()

print("\nCONFUSION MATRIX FOR PART 2.1(b)")
print("Using cached predictions generated by 'question2_1b.py'...")
prediction_data = numpy.loadtxt('2_1b_test_prediction.csv', delimiter=',')
print(prediction_data)

# Confusion Matrix

confusion_matrix = numpy.empty((2, 2), dtype=numpy.int64)
for i in range(2):
    label_i_mask = (test_Y_subset==(i+4))
    for j in range(2):
        predicted_j_actual_i = (prediction_data[label_i_mask]==(j+4))        
        # confusion_matrix[i,j] = no. of examples of actual class (i+4) predicted as class (j+4)
        confusion_matrix[i,j] = numpy.count_nonzero(predicted_j_actual_i)
print("\nConfusion Matrix: (i,j) th value represents no. of examples of actual class (i+4) predicted as class (j+4)")        
print(confusion_matrix)

print("\nSome Misclassified Images")

misclassified_images = test_X_subset[prediction_data!=test_Y_subset]
labels = test_Y_subset[prediction_data!=test_Y_subset]
predicted = prediction_data[prediction_data!=test_Y_subset]
misclassified_images = (255*misclassified_images).astype(numpy.uint8)
w, h = 28, 28

fig, axs = plt.subplots(1, 2)
fig.set_size_inches(8, 4)
for j in range(2):
    axs[j].plot()
    axs[j].imshow(numpy.reshape(misclassified_images[j], newshape=(w,h)), cmap=plt.get_cmap('gray'))
    axs[j].set_title(f"L={labels[j]} P={int(predicted[j])}")

# Hide x labels and tick labels for top plots and y ticks for right plots.
for ax in axs.flat:
    ax.label_outer()

plt.savefig("2_2c_i2_misclassified_images.png", dpi=100)
plt.show()

num_classes = numpy.unique(train_Y).size
num_classifiers = numpy.int64(((num_classes)*(num_classes-1))/2)

print("\nCONFUSION MATRIX FOR PART 2.2(a)")
print("Using cached predictions generated by 'question2_2a.py'...")
prediction_data = numpy.loadtxt('2_2a_test_prediction.csv', delimiter=',')
print(prediction_data)


# Confusion Matrix

confusion_matrix = numpy.empty((num_classes, num_classes), dtype=numpy.int64)
for i in range(num_classes):
    label_i_mask = (test_Y==(i))
    for j in range(num_classes):
        predicted_j_actual_i = (prediction_data[label_i_mask]==(j))        
        # confusion_matrix[i,j] = no. of examples of actual class (i) predicted as class (j)
        confusion_matrix[i,j] = numpy.count_nonzero(predicted_j_actual_i)
print("\nConfusion Matrix: (i,j) th value represents no. of examples of actual class (i) predicted as class (j)")        
print(confusion_matrix)

print("\nSome Misclassified Images")

misclassified_images = test_X[prediction_data!=test_Y]
labels = test_Y[prediction_data!=test_Y]
predicted = prediction_data[prediction_data!=test_Y]
misclassified_images = (255*misclassified_images).astype(numpy.uint8)
w, h = 28, 28

fig, axs = plt.subplots(4, 4)
fig.set_size_inches(8, 8)
for i in range(4):
    for j in range(4):
        axs[i, j].plot()
        axs[i, j].imshow(numpy.reshape(misclassified_images[4*i + j], newshape=(w,h)), cmap=plt.get_cmap('gray'))
        axs[i, j].set_title(f"L={labels[4*i + j]} P={int(predicted[4*i + j])}")

# Hide x labels and tick labels for top plots and y ticks for right plots.
for ax in axs.flat:
    ax.label_outer()

plt.savefig("2_2c_i3_misclassified_images.png", dpi=100)
plt.show()

print("\nCONFUSION MATRIX FOR PART 2.2(b)")
print("Using cached predictions generated by 'question2_2b.py'...")
prediction_data = numpy.loadtxt('2_2b_test_prediction.csv', delimiter=',')
print(prediction_data)

# Confusion Matrix

confusion_matrix = numpy.empty((num_classes, num_classes), dtype=numpy.int64)
for i in range(num_classes):
    label_i_mask = (test_Y==(i))
    for j in range(num_classes):
        predicted_j_actual_i = (prediction_data[label_i_mask]==(j))        
        # confusion_matrix[i,j] = no. of examples of actual class (i) predicted as class (j)
        confusion_matrix[i,j] = numpy.count_nonzero(predicted_j_actual_i)
print("\nConfusion Matrix: (i,j) th value represents no. of examples of actual class (i) predicted as class (j)")        
print(confusion_matrix)

print("\nSome Misclassified Images")

misclassified_images = test_X[prediction_data!=test_Y]
labels = test_Y[prediction_data!=test_Y]
predicted = prediction_data[prediction_data!=test_Y]
misclassified_images = (255*misclassified_images).astype(numpy.uint8)
w, h = 28, 28

fig, axs = plt.subplots(4, 4)
fig.set_size_inches(8, 8)
for i in range(4):
    for j in range(4):
        axs[i, j].plot()
        axs[i, j].imshow(numpy.reshape(misclassified_images[4*i + j], newshape=(w,h)), cmap=plt.get_cmap('gray'))
        axs[i, j].set_title(f"L={labels[4*i + j]} P={int(predicted[4*i + j])}")

# Hide x labels and tick labels for top plots and y ticks for right plots.
for ax in axs.flat:
    ax.label_outer()

plt.savefig("2_2c_i4_misclassified_images.png", dpi=100)
plt.show()

